# -*- coding: utf-8 -*-
"""Program_LSTM_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dIe2Lr9_POahRfPj7-cwPcvYGHk60uv6

# **Dataset Kualitas Lingkungan sungai Oyo (Data Pribadi)**

## Import Library
"""

# Importing libraries
import tensorflow as tf
import matplotlib.pyplot as plt
import matplotlib as mpl
import pandas as pd
import numpy as np
import os
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.callbacks import EarlyStopping

mpl.rcParams['figure.figsize'] = (8,6)
mpl.rcParams['axes.grid'] = False

"""# Data Wrangling

## Data Akuisisi
"""

# koneksikan dengan drive
from google.colab import drive
drive.mount('/content/drive')

# ambil data
file_path = '/content/drive/MyDrive/AQUASENSE/data_sensor.csv'
data = pd.read_csv(file_path)

# Baca dataset dari CSV
data.head()

# jumlah data
print(len(data))

"""## Data Asessing"""

data.info()

data.isna().sum()

print('duplikasi data: ', data.duplicated().sum())

data.describe()

"""## Data Cleaning and encoding

kolom cuaca dihapus karena ada banyak nilai yang berisi 0 dibanding 1 dan cuaca ini ambigu karena hanyak menampilkan 0 atau 1 oleh karena itu kolom cuaca dihapus
"""

# Menghapus kolom 'Cuaca'
data = data.drop(columns=['Cuaca'])
data.head()

# encoding waktu ke numerik
df = pd.DataFrame(data)

# Mengonversi kolom 'Waktu' ke format datetime
df['Waktu'] = pd.to_datetime(df['Waktu'], format='%d/%m/%Y %H:%M')
# Mengubah menjadi numerik (timestamp dalam detik sejak epoch)
df['Waktu_numerik'] = df['Waktu'].astype('int64') / 10**9  # Mengonversi ke detik

# Menghapus kolom 'Waktu'
data = data.drop(columns=['Waktu'])
data.head()

df.info()

df.isna().sum()

"""# Exploratory Data Analisis"""

df.head()

# deskripsi statistik
df.describe()

# distribusi data
import seaborn as sns
import matplotlib.pyplot as plt

sns.histplot(df['suhu udara'], kde=True)
plt.title('Distribusi Suhu Udara')
plt.show()

sns.histplot(df['humidty'], kde=True)
plt.title('Distribusi Kelembapan')
plt.show()

sns.histplot(df['suhu air'], kde=True)
plt.title('Distribusi Suhu Air')
plt.show()

df['Waktu'] = pd.to_datetime(df['Waktu'])

# Plot Suhu Udara terhadap Waktu
plt.figure(figsize=(10, 6))
sns.lineplot(x=df['Waktu'], y=df['suhu udara'])
plt.title('Suhu Udara Sepanjang Waktu')
plt.xticks(rotation=45)
plt.show()

# Plot Kelembapan terhadap Waktu
plt.figure(figsize=(10, 6))
sns.lineplot(x=df['Waktu'], y=df['humidty'])
plt.title('Kelembapan Sepanjang Waktu')
plt.xticks(rotation=45)
plt.show()

# Plot Suhu Air terhadap Waktu
plt.figure(figsize=(10, 6))
sns.lineplot(x=df['Waktu'], y=df['suhu air'])
plt.title('Suhu Air Sepanjang Waktu')
plt.xticks(rotation=45)
plt.show()

# matriks korelasi
correlation_matrix = df[['suhu udara', 'humidty', 'suhu air']].corr()
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Matrix Korelasi')
plt.show()

"""# Data Prepropcesing

## Cek Outlier
"""

df.head()

# Pilih hanya kolom dengan tipe data numerik
numeric_columns = df.select_dtypes(include=['number']).columns

# Plot boxplot hanya untuk kolom numerik
for feature in numeric_columns:
    plt.figure(figsize=(10, 5))
    plt.boxplot(x=df[feature])
    plt.title(f"Box Plot Of {feature}")
    plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Pilih hanya kolom dengan tipe data numerik
numeric_columns = df.select_dtypes(include=['number']).columns

# Tangani outlier dengan mengganti dengan median atau mean
for feature in numeric_columns:
    Q1 = df[feature].quantile(0.25)
    Q3 = df[feature].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    # Buat mask untuk outlier
    outliers = (df[feature] < lower_bound) | (df[feature] > upper_bound)

    # Ganti outlier dengan median (atau bisa ganti jadi df[feature].mean())
    median_value = df[feature].median()
    df.loc[outliers, feature] = median_value

df.head()

# Plot boxplot setelah penanganan outlier
    plt.figure(figsize=(10, 5))
    plt.boxplot(x=df[feature])
    plt.title(f"Box Plot Of {feature} (After Outlier Handling)")
    plt.show()

"""## Standarisasi Data"""

df.isna().sum()

df.info()

data_filter = df.copy()

# Inisialisasi StandardScaler
scaler = StandardScaler()

# Copy data asli
data_scaled = data_filter.copy()

# Pilih hanya kolom numerik
numerical_cols = data_filter.select_dtypes(include=['number']).columns

# Standarisasi kolom numerik
data_scaled[numerical_cols] = scaler.fit_transform(data_filter[numerical_cols])

# Tampilkan hasil
data_scaled.describe()

"""# LSTM Multivariate prediksi suhu air dengan feature suhu udara, humidty dan waktu

### Build model
"""

# Fitur dan target
features = ['suhu udara', 'humidty', 'Waktu_numerik']
target = 'suhu air'

# Fungsi untuk membuat sequence multivariate
def create_sequences(X, y, time_steps=10):
    Xs, ys = [], []
    for i in range(len(X) - time_steps):
        Xs.append(X[i:i+time_steps])
        ys.append(y[i+time_steps])
    return np.array(Xs), np.array(ys)

# Siapkan data
X = df[features].values
y = df[target].values

# Feature scaling (normalisasi)
scaler_X = MinMaxScaler(feature_range=(0, 1))
scaler_y = MinMaxScaler(feature_range=(0, 1))

X_scaled = scaler_X.fit_transform(X)
y_scaled = scaler_y.fit_transform(y.reshape(-1, 1))

# Ubah menjadi format LSTM
time_steps = 10
X_seq, y_seq = create_sequences(X_scaled, y_scaled, time_steps)

# Split train/test
X_train, X_test, y_train, y_test = train_test_split(X_seq, y_seq, test_size=0.2, random_state=42)

# Bangun model LSTM yang lebih kompleks
model = Sequential()

# Lapisan LSTM pertama dengan dropout
model.add(LSTM(128, activation='relu', return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(Dropout(0.3))

# Lapisan LSTM kedua dengan dropout
model.add(LSTM(64, activation='relu', return_sequences=True))
model.add(Dropout(0.3))

# Lapisan LSTM ketiga dengan dropout
model.add(LSTM(32, activation='relu'))
model.add(Dropout(0.3))

# Lapisan Dense untuk output
model.add(Dense(1))

# Kompilasi model
model.compile(optimizer='adam', loss='mse')

# Gunakan EarlyStopping untuk menghindari overfitting
early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

"""### Runing Model"""

# Latih model
history = model.fit(
    X_train, y_train,
    validation_data=(X_test, y_test),
    epochs=200,
    batch_size=64,
    callbacks=[early_stopping]
)

"""### Evaluasi model"""

# Prediksi pada data testing
y_pred_train = model.predict(X_train)
y_pred_test = model.predict(X_test)

# Inversi scaling
y_pred_train = scaler_y.inverse_transform(y_pred_train)
y_pred_test = scaler_y.inverse_transform(y_pred_test)
y_train = scaler_y.inverse_transform(y_train)
y_test = scaler_y.inverse_transform(y_test)

# Evaluasi model
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# MAE, MSE, RMSE, dan R² pada data training dan testing
mae_train = mean_absolute_error(y_train, y_pred_train)
mse_train = mean_squared_error(y_train, y_pred_train)
rmse_train = np.sqrt(mse_train)
r2_train = r2_score(y_train, y_pred_train)

mae_test = mean_absolute_error(y_test, y_pred_test)
mse_test = mean_squared_error(y_test, y_pred_test)
rmse_test = np.sqrt(mse_test)
r2_test = r2_score(y_test, y_pred_test)

# Menampilkan hasil evaluasi
print(f"Training MAE: {mae_train}, MSE: {mse_train}, RMSE: {rmse_train}, R²: {r2_train}")
print(f"Testing MAE: {mae_test}, MSE: {mse_test}, RMSE: {rmse_test}, R²: {r2_test}")

# Visualisasi Hasil
plt.figure(figsize=(10,6))
plt.plot(y_test, label='Suhu Air Aktual')
plt.plot(y_pred_test, label='Suhu Air Prediksi')
plt.legend()
plt.title('Perbandingan Suhu Air Aktual dan Prediksi')
plt.show()

"""# Kesimpulan

Hasil ini menunjukkan performa model yang cukup baik, tetapi ada beberapa hal yang bisa diperhatikan:

1. MAE (Mean Absolute Error):
  - Training MAE: 0.0853
  - Testing MAE: 0.0918
  - MAE yang rendah menunjukkan bahwa prediksi model cukup dekat dengan nilai sebenarnya. Perbedaan antara training dan testing MAE juga relatif kecil, yang menunjukkan model tidak overfitting.

2. MSE (Mean Squared Error):
  - Training MSE: 0.0214
  - Testing MSE: 0.0230
  - MSE yang lebih rendah juga menunjukkan kesalahan prediksi yang relatif kecil.

3. RMSE (Root Mean Squared Error):
  - Training RMSE: 0.1462
  - Testing RMSE: 0.1517
  - RMSE yang lebih kecil lebih baik, dan angka ini juga menunjukkan kesalahan yang relatif kecil pada model.

4. R² (Coefficient of Determination):
  - Training R²: 0.8246
  - Testing R²: 0.8077
  - Nilai R² mendekati 1, yang berarti model dapat menjelaskan sebagian besar variansi data. R² yang tinggi menunjukkan model bekerja dengan baik dalam memprediksi data.
"""